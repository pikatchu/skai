module alias AF = ArrayFire;

module Tensor;

type Env = Map<String, ArrayFire.Array>;

base class OperationKind {
  children =
  | Multiply()
  | Divide()
  | Add()
  | Sub()
}

class Int(value: .Int) extends Tensor {
  fun *(rhs: Tensor): Tensor {
    ConstantOfInt(this.value, rhs) * rhs
  }

  fun +(rhs: Tensor): Tensor {
    ConstantOfInt(this.value, rhs) + rhs
  }

  fun -(rhs: Tensor): Tensor {
    ConstantOfInt(this.value, rhs) - rhs
  }

  fun /(rhs: Tensor): Tensor {
    ConstantOfInt(this.value, rhs) / rhs
  }

  fun negate(): Tensor {
    !this.value = -this.value;
    this
  }

  fun reciprocal(): Tensor {
    invariant_violation("Reciprocal on Int not supported")
  }
}

base class .Tensor {
  children =
  | Input(String)
  | Constant(Float, .Int)
  | ConstantOfInt(.Int, Tensor)
  | Operation(OperationKind, Tensor, Tensor)
  | Negate(Tensor)
  | Reciprocal(Tensor)

  overridable fun *(rhs: Tensor): Tensor {
    rhs match {
    | Int(n) -> this * ConstantOfInt(n, this)
    | _ -> Operation(Multiply(), this, rhs)
    }
  }

  overridable fun /(rhs: Tensor): Tensor {
    rhs match {
    | Int(n) -> this / ConstantOfInt(n, this)
    | _ -> Operation(Divide(), this, rhs)
    }
  }

  overridable fun +(rhs: Tensor): Tensor {
    rhs match {
    | Int(n) -> this + ConstantOfInt(n, this)
    | _ -> Operation(Add(), this, rhs)
    }
  }

  overridable fun -(rhs: Tensor): Tensor {
    rhs match {
    | Int(n) -> this - ConstantOfInt(n, this)
    | _ -> Operation(Sub(), this, rhs)
    }
  }

  overridable fun negate(): Tensor {
    Negate(this)
  }

  overridable fun reciprocal(): Tensor {
    Reciprocal(this)
  }

  protected fun buildGradients(
    gradient: Tensor,
    acc: mutable Map<String, Tensor>,
  ): void
  | Int _
  | Constant _
  | ConstantOfInt _ ->
    void
  | Input(name) ->
    acc![name] = if (acc.containsKey(name)) acc[name] + gradient else gradient
  | Operation(operator, lhs, rhs) ->
    operator match {
    | Multiply() ->
      lhs.buildGradients(gradient * rhs, acc);
      rhs.buildGradients(gradient * lhs, acc)
    | Divide() ->
      rhsRec = rhs.reciprocal();
      lhsGrad = gradient * rhsRec;
      lhs.buildGradients(lhsGrad, acc);
      rhs.buildGradients(lhsGrad * lhs.negate() * rhsRec, acc)
    | Add() ->
      lhs.buildGradients(gradient, acc);
      rhs.buildGradients(gradient, acc)
    | Sub() ->
      lhs.buildGradients(gradient, acc);
      rhs.buildGradients(-gradient, acc)
    }
  | Negate(tensor) -> tensor.buildGradients(-gradient, acc)
  | Reciprocal(tensor) ->
    res = tensor.reciprocal();
    tensor.buildGradients(gradient.negate() * res * res, acc)

  fun backward(gradient: Tensor): Map<String, Tensor> {
    acc = mutable Map[];
    this.buildGradients(gradient, acc);
    freeze(acc)
  }

  async fun asyncEval(env: Env): ^AF.Array {
    this match {
    | Int _ -> invariant_violation("Bad usage of Tensor.Int")
    | Input(n) ->
      if (!env.containsKey(n)) {
        invariant_violation(`Environment does not define the input ${n}`)
      } else {
        env[n]
      }
    | ConstantOfInt(value, tensor) ->
      AF.constant_of_int(value, await tensor.asyncEval(env))
    | Constant(value, dims) -> AF.constant(value, dims)
    | Operation(operator, lhsTree, rhsTree) ->
      lhs = await lhsTree.asyncEval(env);
      rhs = await rhsTree.asyncEval(env);
      operator match {
      | Multiply() -> AF.mult_aa(lhs, rhs)
      | Divide() -> AF.div_aa(lhs, rhs)
      | Add() -> AF.plus_aa(lhs, rhs)
      | Sub() -> AF.minus_aa(lhs, rhs)
      }
    | Negate(v) -> AF.negate(await v.asyncEval(env))
    | Reciprocal(v) -> AF.div_fa(1.0, await v.asyncEval(env))
    }
  }

  fun eval(env: Env): AF.Array {
    awaitSynchronously(this.asyncEval(env))
  }
}

module end;

module TestTensor;

fun verify(v: AF.Array): void {
  res = AF.allTrue(AF.lt_av(AF.abs(v), 1E-5));
  if (res) print_string("PASSED") else print_string("FAILED")
}

fun test_multiply(env: Tensor.Env): void {
  x = Tensor.Input("x");
  y = x * x;
  dy = Tensor.Constant(1.0, 5);
  grads = y.backward(dy);
  dx = grads["x"];
  arr = dx.eval(env) - AF.mult_ia(2, x.eval(env));
  verify(arr);
}

fun test_multiply_add(env: Tensor.Env): void {
  x = Tensor.Input("x");
  y = Tensor.Input("y");
  z = x * x + x * y + y * y;
  dz = Tensor.Constant(1.0, 5);
  grads = z.backward(dz);
  dx = grads["x"];
  dy = grads["y"];
  verify(dx.eval(env) - AF.mult_ia(2, x.eval(env)) - y.eval(env));
  verify(dy.eval(env) - AF.mult_ia(2, y.eval(env)) - x.eval(env));
}

fun test_multiply_sub(env: Tensor.Env): void {
  x = Tensor.Input("x");
  y = Tensor.Input("y");
  z = x * x - x * y;
  dz = Tensor.Constant(1.0, 5);
  grads = z.backward(dz);
  dx = grads["x"];
  dy = grads["y"];
  verify(dx.eval(env) - (AF.mult_ia(2, x.eval(env)) - y.eval(env)));
  verify(dy.eval(env) - (-x.eval(env)));
}

fun test_divide_add(env: Tensor.Env): void {
  x = Tensor.Input("x");
  y = Tensor.Input("y");
  z = x + x / y + y;
  dz = Tensor.Constant(1.0, 5);
  grads = z.backward(dz);
  dx = grads["x"];
  dy = grads["y"];
  verify(dx.eval(env) - (AF.plus_fa(1.0, AF.div_fa(1.0, y.eval(env)))));
  verify(
    dy.eval(env) -
      (AF.minus_fa(1.0, (x.eval(env) / (y.eval(env) * y.eval(env))))),
  );
}

fun test_multiply_add_scalar(env: Tensor.Env): void {
  x = Tensor.Input("x");
  y = Tensor.Input("y");
  z = x * Tensor.Int(2) + x * y + y;
  dz = Tensor.Constant(1.0, 5);
  grads = z.backward(dz);
  dx = grads["x"];
  dy = grads["y"];
  verify(dx.eval(env) - (AF.plus_fa(2.0, y.eval(env))));
  verify(dy.eval(env) - (AF.plus_fa(1.0, x.eval(env))));
}

untracked fun testAll(): void {
  env = Map["x" => AF.randu(5), "y" => AF.randu(5)];
  test_multiply(env);
  test_multiply_add(env);
  test_multiply_sub(env);
  test_divide_add(env);
  test_multiply_add_scalar(env);
}

module end;
