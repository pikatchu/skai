module alias AF = ArrayFire;

untracked fun makeMLP(dims: Vector<Int>, env: mutable Tensor.Params): Skai.Model {
  seq = mutable Vector<Skai.Model>[];
  for (i in Range(0, dims.size() - 1)) {
    w_i = env.add(AF.randu(dims[i], dims[i+1]), `w_${i}`);

    seq.push(Skai.Linear(w_i));
    seq.push(Skai.Sigmoid());
  };
  Skai.Seq(freeze(seq))
}

untracked fun buildSimpleExample(): void {
  data = Range(0, 20).map(_ -> { x = AF.randu(1); (x, AF.sin(x)) });
  eval = Range(0,  5).map(_ -> { x = AF.randu(1); (x, AF.sin(x)) });

  params = mutable Tensor.Params();
  w_0 = params.add(AF.randu(1, 10));
  w_1 = params.add(AF.randu(10, 1));
  model = Skai.Seq[Skai.Linear(w_0),
                   Skai.Sigmoid(),
                   Skai.Linear(w_1),
                   Skai.Sigmoid()];

  trainer = mutable Skai.Trainer{
    model,
    loss_fun => Loss.mse,
    opt => Skai.SGD{lr => 1.0},
    params
  };

  for (epoch in Range(0, 1000)) {
    trainer.step(data);
    print_string(`Epoch #${epoch}\t  Loss: ${trainer.loss(eval)}\t (train loss: ${trainer.loss(data)})`)
  };
}
