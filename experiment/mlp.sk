module alias AF = ArrayFire;
module alias NN = SkaiModel;

untracked fun makeMLP(dims: Vector<Int>, params: mutable Tensor.Params): NN.Model {
  seq = mutable Vector<NN.Model>[];
  for (i in Range(0, dims.size() - 1)) {
    w_i = params.add(AF.randu(dims[i], dims[i+1]), `w_${i}`);

    seq.push(NN.Linear(w_i));
    seq.push(NN.Sigmoid());
  };
  NN.Seq(freeze(seq))
}

untracked fun buildSimpleExample(): void {
  data = Range(0, 20).map(_ -> { x = AF.randu(1); (x, AF.sin(x)) });
  eval = Range(0,  5).map(_ -> { x = AF.randu(1); (x, AF.sin(x)) });

  params = mutable Tensor.Params();
  w_0 = params.add(AF.randu(1, 10));
  w_1 = params.add(AF.randu(10, 1));
  model = NN.Seq[NN.Linear(w_0),
                 NN.Sigmoid(),
                 NN.Linear(w_1),
                 NN.Sigmoid()];

  trainer = mutable Skai.Trainer{
    model,
    loss_fun => Loss.mse,
    opt => Optimizer.SGD{lr => 1.0},
    params
  };

  for (epoch in Range(0, 1000)) {
    trainer.step(data);
    print_string(`Epoch #${epoch}\t  Loss: ${trainer.loss(eval)}\t (train loss: ${trainer.loss(data)})`)
  };
}
