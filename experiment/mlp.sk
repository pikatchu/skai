module alias AF = ArrayFire;
module alias NN = SkaiModel;

untracked fun makeMLP(dims: Vector<Int>, params: mutable Tensor.Params): NN.Model {
  seq = mutable Vector<NN.Model>[];
  for (i in Range(0, dims.size() - 1)) {
    w_i = params.add(AF.randu(dims[i], dims[i+1]), `w_${i}`);

    seq.push(NN.Linear(w_i));
    seq.push(NN.Sigmoid());
  };
  NN.Seq(freeze(seq))
}

untracked fun buildSimpleExample(): void {
  data = Range(0, 20).map(_ -> { x = AF.randu(1); (x, AF.sin(x)) });
  _eval = Range(0,  5).map(_ -> { x = AF.randu(1); (x, AF.sin(x)) });

  params = mutable Tensor.Params();
  w_0 = params.add(AF.randu(1, 10));
  w_1 = params.add(AF.randu(10, 1));
  model = NN.Seq[NN.Linear(w_0),
                 NN.Sigmoid(),
                 NN.Linear(w_1),
                 NN.Sigmoid()];

  optimizer = Optimizer.SGD{lr => 1.0};

  for (epoch in Range(0, 1000)) {
    avg_loss = 0.0;
    for (d in data) {
      (xi, yi) = d;
      // xs = data.map(d -> { d.i0 });
      // ys = data.map(d -> { d.i1 });
      outputs = model.forward(Tensor.Input(xi));
      loss = Loss.mse(outputs, Tensor.Input(yi));
      grads = loss.backward(params);
      optimizer.step(params, grads);
      !avg_loss = avg_loss + loss.eval(params).array().scalar();
    };
    print_string(`Epoch #${epoch}\t  Loss: ${avg_loss / data.size().toFloat()}`);
  };
}
