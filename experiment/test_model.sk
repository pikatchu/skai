module alias AF = ArrayFire;

mutable class Env(
  data: mutable Map<String, AF.Array> = mutable Map[],
  mutable currentId: Int = 0,
) {
  mutable private fun genSym(): String {
    this.!currentId = this.currentId + 1;
    "tmp" + this.currentId.toString()
  }

  mutable fun parameter(weights: AF.Array): Tensor {
    name = this.genSym();
    this.data![name] = weights;
    Tensor.Input(name)
  }
}

mutable base class Model {
  children =
  | Sigmoid()
  | Seq(Vector<Model>)
  | Linear(Int, Int)

  untracked fun instantiate(env: mutable Env, input: Tensor): Tensor
  | Sigmoid() -> Tensor.dummySigmoid(input)
  | Linear(n, m) ->
    weights = AF.randu(n * m);
    env.parameter(weights) * input
  | Seq(v) ->
    acc = input;
    v.each(x -> !acc = x.instantiate(env, acc));
    acc
}

untracked fun makeMLP(dims: Vector<Int>): Model {
  seq = mutable Vector<Model>[];
  for (i in Range(0, dims.size() - 1)) {
    xi0 = dims[i];
    xi1 = dims[i + 1];
    seq.push(Linear(xi0, xi1));
    seq.push(Sigmoid());
  };
  Seq(freeze(seq))
}

untracked fun buildSimpleExample(): void {
  mlp = makeMLP(Vector[3, 4]);
  env = mutable Env();
  input = env.parameter(AF.randu(3));
  output = mlp.instantiate(env, input);
  arr = output.eval(freeze(env.data));
  AF.print(arr)
}
